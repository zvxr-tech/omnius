/*
 * This contains code to convert a DFA generated from the original program into a format that is understood by omnius.
 * Based on code from:
 * Eli Bendersky (eliben@gmail.com)
 * Retrieved from:
 * https://github.com/eliben/code-for-blog/blob/master/2009/regex_fsm/regex_parse.cpp
 *
 *
 * Modified 2015 - Mike Clark
 */
#ifndef DFA_H
#define DFA_H

#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "../fsm_descriptor.h"


class DFA
{
public:
    typedef pair<state, input> transition;

    // transition table, set of final states and the start state
    //
    map<transition, state> trans_table;
    state start;
    set<state> final;


    /*
     * This routine converts a DFA graph desrciption generated by the regex_parse program into a jmp table that can
     * be used by omnius. This is one part in the chain used to compile a fsm_descriptor from a char sequence
     * regex.
     * 
     * Expressing what we are doing programmatically with a graph equivalence:
     * 
     * First, add an extra transition from every non-sink node to the non sink node. The transition is on the
     * special null symbol (zero'th symbol, 0).
     * 
     * Next, the existing state=0 node is re-labeled (swapped) with the existing sink-state. So, that the
     * sink state is now state=0.
     *
     * Then, what was the state=0 (and now state=existing_sink) is swapped with the state=1 node. This is
     * because the ragasm object that uses the fsm_descriptor expects the entry at the state=1 node.
     * 
     * In effect, 
     *  the sink state label in the DFA becomes state 0 in the jmp table,
     *  the 0 label state in the DFA becomes state 1 (entry) in the jmp table, and
     *  the label state 1 in the DFA becomes the state sink position in the jmp table.
     * 
     * The code this is based off of constructs a DFA with a start state of 0, and (depending on the regex) a
     * non-zero invalid sink state. (We wrap all regex's in a kleen star so there should only be one invalid
     * state generated, since it is a "minimized" graph.)
     * 
     * Our jmp table uses state zero for a sink and state 1 for entry, so we need to fix that. This is a side 
     * thing for a POC so it's easier to hack this together here, but not as pretty.
     * 
     * If there is not an existing sink state (invalid state) in the DFA, construct_jmptbl will have
     * undefined behaviour. ENSURE THAT YOUR REGEX DOES NOT ACCEPT EVERYTHING!
     *
     * The trans_table effectively has two keys, current_state and input_symbol. will be first ordered by state
     * (ascending), then by input (ascending: A-Za-Z).
     * We take advantage of this ordering to insert missing transitions, specifically the null transition and any
     * symbols not encountered in the regex, but are part of the alphabet nonetheless.
     *
     * Since the null symbol acts static (always transition to the sink), and because it would be a big hassle to deal
     * with it (displaying as human-readable, regex parser) it is easier to insert it into the transition table that
     * this program generates.
     *
     * This algorithm generates a jmp table based on a alphabet that is implied from the regex supplied (I.e. only symbols found
     * there). Although OMNIUS may receive symbols beyond those, a mapping function reduces that set to the symbols used
     * in the regex, and all the rest map to zero. For example, with regex="WRWW*", the following alpha_map would be
     * generated:
     *
     * alpha_map[0] = 0  //always maps to itself (NULL symbol)
     * alpha_map[1] = 0
     * ...
     * alpha_map['Q'] = 0
     * alpha_map['R'] = 1
     * alpha_map['S'] = 0
     * alpha_map['T'] = 0
     * alpha_map['U'] = 0
     * alpha_map['V'] = 0
     * alpha_map['W'] = 2
     * alpha_map['X'] = 0
     * ...
     * alpha_map[254] = 0
     * alpha_map[255] = 0
     *
     * NOTE: The alpha_map value of it's respective index is numbered in ascending order .
     *
      * CONVERTING DFA -> JMP TABLE
     *  i) Add in extra space for NULL input symbol transition at the start of every state grouping in a new buffer.
     *  ii) identify the existing sink state label while copying the trans_table to the new buffer (jmp_tbl).
     *      This will also introduce an entry at the beginning of every set of sr state's mapping the null symbol to
     *      the exiting sink state.
     *  iii) Re-lable states. This is deone because the omnius system expects the FSM to start in the 1st state, and
     *      reserves the zero'th state as a special null-sink state.
     *
     *
     *
     * trans_table assumptions,
     *  the trans_table has the same number of symbol enries per src_state. The symbols appear in the order of their
     *  ACII encoding. (ie. [A...Z,a...z])
     *  The ordering of the table is ranked by in the following key order (ascending): src_state, input_symbol.
     *  So that the output will be similar to this.
     *
     *       Trans[0, R] = 1
     *       Trans[0, W] = 2
     *       Trans[1, R] = 2
     *       Trans[1, W] = 3
     *       Trans[2, R] = 2
     *       Trans[2, W] = 2
     *       Trans[3, R] = 4
     *       Trans[3, W] = 5
     *       Trans[4, R] = 4
     *       Trans[4, W] = 5
     *       Trans[5, R] = 2
     *       Trans[5, W] = 2
     *
     *
     *
     * This routine is not responsible for freeing the jmp_tbl after this routine succeeds.
     */
    size_t construct_jmptbl(SYMBOL_T *alpha_map, STATE_T **jmp_tbl_p) {
        const int null_state = 0;
        const int entry_state = 1;
        STATE_T trans_table_sink_state = 0;
        char sink_found = FALSE;

        /* Do some precalculations. */
        size_t trans_table_state_count = trans_table.rbegin()->first.first + 1;
        size_t trans_table_symbol_count = trans_table.size() / trans_table_state_count;
        size_t jmp_tbl_symbol_count = trans_table_symbol_count + 1;
        //assert ((trans_table.size() % trans_table_state_count) == 0);

        /* add space for one null sym per state set */
        size_t jmp_tbl_size = trans_table.size() + (trans_table_state_count * sizeof(STATE_T));
        *jmp_tbl_p = (STATE_T *) calloc(jmp_tbl_size, sizeof(STATE_T));
        STATE_T *jmp_tbl = *jmp_tbl_p;
        if ( !jmp_tbl) {
            return 0; /* Error */
        }


        /* DEBUG */
        for (map<transition, state>::const_iterator i = trans_table.begin(); i != trans_table.end(); ++i)
        {
            cout << "Trans[" << (i->first).first << ", " << (i->first).second << "] = " << i->second << endl;

        }



        /* identify sink state and copy out the trans_table to the jmp table buffer */
        size_t j = 0;
        STATE_T k = 0;
        for (map<transition, state>::const_iterator i = trans_table.begin(); i != trans_table.end(); ++i, ++k) {
            if (!(k / trans_table_symbol_count)) {
                /* run during first set of states (=0) to map the input symbols to an internal, packed enumeration */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored  "-Wchar-subscripts"
                /* IGNORE_WARNING: Trying to stuff int into char index size */
                alpha_map[(i->first).second] = k + 1; /* map each input symbol with it's internal id */
#pragma GCC diagnostic pop
            }

            if (i->second == (i->first).first)
                j++;

            /* test if this is the last element of the same src state */
            if (((k + 1) % trans_table_symbol_count) == 0 ) {
                if (j == trans_table_symbol_count) {
                    /* found a sink state since every transition points back to itself */
                    trans_table_sink_state = (STATE_T) (k / trans_table_symbol_count);
                    sink_found = TRUE;
                }
//                assert (j <= trans_table_symbol_count);
                j = 0;
            }

            /* copy into the jump table, calculating in the null symbol spaces we  want to insert
             * [offset + null_sym displacement] */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored  "-Wchar-subscripts"
            jmp_tbl[k + (k / trans_table_symbol_count) + 1] = i->second;
#pragma GCC diagnostic pop
        }
        if (!sink_found) {
            free(jmp_tbl_p);
            return 0; /* Error */
        }

        /* fill in the null symbol dst states with the existing sink state found */
        for (k = 0; k < jmp_tbl_size; k += jmp_tbl_symbol_count)
            jmp_tbl[k] = trans_table_sink_state;


        /* DEBUG */
#ifdef DEBUG
        for (k = 0; k < jmp_tbl_size; ++k) {
            cout << "jmp_tbl[" <<  (k / jmp_tbl_symbol_count) << ", " << (k % jmp_tbl_symbol_count) << "] = " << (int) jmp_tbl[k] << endl;
        }
#endif


        /* XOR swap entry state and existing sink state, for each input symbol entry */
        for (k=0; k < jmp_tbl_symbol_count; ++k) {
            jmp_tbl[(null_state * jmp_tbl_symbol_count) + k]          ^= jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k];
            jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k] ^= jmp_tbl[(null_state * jmp_tbl_symbol_count) + k];
            jmp_tbl[(null_state * jmp_tbl_symbol_count) + k]          ^= jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k];

        }

        /* XOR swap entry state (now in the original sink state) and existing state #1, for each input symbol
         * entry
         */
        for (k=0; k < jmp_tbl_symbol_count; ++k) {

            jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k]   ^= jmp_tbl[(entry_state * jmp_tbl_symbol_count) + k];
            jmp_tbl[(entry_state * jmp_tbl_symbol_count) + k]           ^= jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k];
            jmp_tbl[(trans_table_sink_state * jmp_tbl_symbol_count) + k]   ^= jmp_tbl[(entry_state * jmp_tbl_symbol_count) + k];

        }


/* DEBUG */
#ifdef DEBUG
        for (k = 0; k < jmp_tbl_size; ++k) {
            cout << "jmp_tbl_postswap[" <<  (k / jmp_tbl_symbol_count) << ", " <<  (k % jmp_tbl_symbol_count) << "] = " << (int) jmp_tbl[k] << endl;
        }
#endif

        /* The following has occured:
         * 0 (entry)    -> 1
         * 1            -> sink
         * sink         -> 0
         *
         * Now update all of the index values to match the state label changes made.
         */
        for (k = 0; k < jmp_tbl_size; ++k) {
            if (jmp_tbl[k] ==  null_state)
                jmp_tbl[k] = entry_state;
            else if (jmp_tbl[k] == entry_state)
                jmp_tbl[k] = trans_table_sink_state;
            else if (jmp_tbl[k] == trans_table_sink_state)
                jmp_tbl[k] = null_state;

        }


/* DEBUG */

        for (k = 0; k < jmp_tbl_size; ++k) {
            cout << "jmp_tbl[" << (k / jmp_tbl_symbol_count) << ", " << (k % jmp_tbl_symbol_count) << "] = " << (int) jmp_tbl[k] << endl;
        }

        return jmp_tbl_symbol_count;
    }


};












#endif // DFA_H
